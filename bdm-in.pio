.program bdm_in
.side_set 1 opt

; Set pin direction to output, then, at the 5th cycle, change pin direction and sample data at 10th cycle.
; Then wait till the last cycle(16th) to push data to rx fifo, in order to signal the end of the operation

.wrap_target
    pull                 side 1         ; Copy tx fifo to OSR. Stall here if tx fifo is empty.
    out x, 32                           ; Copy OSR to Scratch Register X, which acts like a loop counter
bit_loop:
    set pindirs, 1       side 0  [3]    ; Set pin to output, set pin low and wait 3 cycles
    set pindirs, 0               [5]    ; Set pin to input and wait 5 cycles
    in pins, 1                   [4]    ; At 10th cycle sample one bit from pin and store it in ISR and wait 4 cycles
    jmp x-- bit_loop 
    set pindirs, 1       side 1
    push                                 ; Push data to RX FIFO
.wrap

% c-sdk {
// Helper function (for use in C program) to initialize this PIO program
void bdm_in_program_init(PIO pio, uint sm, uint offset, uint data_pin, float div, bool shift_right, bool autopush, uint push_threshold) {

    // Sets up state machine and wrap target. This function is automatically
    // generated in bdm.pio.h.
    pio_sm_config c = bdm_in_program_get_default_config(offset);

    // Connect pin to SIDE-SET pin (control with 'side-set' instruction)
    sm_config_set_sideset_pins(&c, data_pin);

    // Connect pin to SET pin (control with 'set' instruction)
    sm_config_set_set_pins(&c, data_pin, 1);

    // Connect pin to IN pin (control with 'in' instruction)
    sm_config_set_in_pins(&c, data_pin);

    // Allow PIO to control GPIO pin (as output)
    pio_gpio_init(pio, data_pin);
    
    // Set the clock divider for the state machine
    sm_config_set_clkdiv(&c, div);

    // Set shift push count threshold.
    sm_config_set_in_shift(&c, shift_right, autopush, push_threshold);

    // Load configuration and jump to start of the program
    pio_sm_init(pio, sm, offset, &c);
}

%}